{"meta":{"title":"天羽ちよこ的新个人站点","subtitle":"喵！","description":"喵！","author":"天羽ちよこ","url":"http://blog.loli.io"},"pages":[],"posts":[{"title":"日麻折腾笔记-02-向听数的判断","slug":"日麻折腾笔记-02-向听数的判断","date":"2019-06-22T01:05:16.000Z","updated":"2019-06-23T09:22:46.000Z","comments":true,"path":"2019/06/22/日麻折腾笔记-02-向听数的判断/","link":"","permalink":"http://blog.loli.io/2019/06/22/日麻折腾笔记-02-向听数的判断/","excerpt":"","text":"思考向听数比较通俗易懂的解释是还差几张牌听牌，用程序能理解的话就是：12将手牌的n张牌替换成任意一张牌，能够满足听牌的n的最小值此时，手牌就是n向听 向听数可以由下面的公式快速算出：1向听数=8-2x(顺子数量+刻子数量)-对子数量-搭子数量 暂不考虑七对子与国士无双 所以只需要算出顺子、刻子、对子以及搭子的数量即可 但是要注意的是，很多牌形是有多种拆分方式的，诸如下面的示例11234s 可以认为是123的顺子加上孤张4，也可以认为是1的孤张加上234的顺子，还可以认为是12和34两个搭子…… 编码我完善了上一章中的代码，将对子、刻子、顺子等概念抽象成类，每种拆分情况都由这四种组成，部分示例代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package io.loli.mj.util.analyze;import io.loli.mj.util.HandPai;import java.util.ArrayList;import java.util.List;/** * 手牌分解的每种组合 * 每种组合都由a个顺子、b个刻子、c个对子、d个搭子、e个孤张组合而成 */public class SplitCondition &#123; private List&lt;Duizi&gt; duiziList = new ArrayList&lt;&gt;(); private List&lt;Shunzi&gt; shunziList = new ArrayList&lt;&gt;(); private List&lt;Dazi&gt; daziList = new ArrayList&lt;&gt;(); private List&lt;Kezi&gt; keziList = new ArrayList&lt;&gt;(); private List&lt;HandPai&gt; guzhangList = new ArrayList&lt;&gt;(); public int xiangTing() &#123; return 8 - 2 * (keziList.size() + shunziList.size()) - daziList.size() - duiziList.size(); &#125; public void addDuizi(Duizi duizi) &#123; duiziList.add(duizi); &#125; public void addShunzi(Shunzi shunzi) &#123; shunziList.add(shunzi); &#125; public void addDazi(Dazi dazi) &#123; daziList.add(dazi); &#125; public void addKezi(Kezi kezi) &#123; keziList.add(kezi); &#125; public void addGuzhang(HandPai guzhang) &#123; guzhangList.add(guzhang); &#125; public List&lt;Duizi&gt; getDuiziList() &#123; return duiziList; &#125; public List&lt;Shunzi&gt; getShunziList() &#123; return shunziList; &#125; public List&lt;Dazi&gt; getDaziList() &#123; return daziList; &#125; public List&lt;Kezi&gt; getKeziList() &#123; return keziList; &#125; public List&lt;HandPai&gt; getGuzhangList() &#123; return guzhangList; &#125; public void setGuzhangList(List&lt;HandPai&gt; guzhangList) &#123; this.guzhangList = guzhangList; &#125; public SplitCondition copy() &#123; SplitCondition condition = new SplitCondition(); condition.duiziList = new ArrayList&lt;&gt;(getDuiziList()); condition.daziList = new ArrayList&lt;&gt;(getDaziList()); condition.keziList = new ArrayList&lt;&gt;(getKeziList()); condition.shunziList = new ArrayList&lt;&gt;(getShunziList()); return condition; &#125; @Override public String toString() &#123; return \"[\" + duiziList + shunziList + daziList + keziList + guzhangList + \"]\"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package io.loli.mj.util.analyze;import io.loli.mj.util.HandAnalyze;import io.loli.mj.util.HandPai;import io.loli.mj.util.Pai;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class PaiSplitter &#123; public static List&lt;SplitCondition&gt; split(String str) &#123; List&lt;HandPai&gt; handPais = HandAnalyze.strToHandPai(str); List&lt;SplitCondition&gt; conditions = new ArrayList&lt;&gt;(); return split(handPais, conditions, new SplitCondition(), 0); &#125; private static List&lt;SplitCondition&gt; split(List&lt;HandPai&gt; handPais, List&lt;SplitCondition&gt; conditions, SplitCondition condition, int depth) &#123; if (depth &gt; 8) &#123; return conditions; &#125; if (handPais.size() &lt;= 1) &#123; conditions.add(condition); return conditions; &#125; HandPai current = null; HandPai next = null; HandPai nextNext = null; current = handPais.get(0); next = handPais.get(1); if (0 != handPais.size() - 2) &#123; nextNext = handPais.get(2); &#125; // 处理对子 if (current.getPai() == next.getPai()) &#123; handleDuizi(handPais, conditions, condition.copy(), current, next, depth + 1); &#125; // 处理刻子 if (nextNext != null) &#123; if (current.getPai() == next.getPai() &amp;&amp; next.getPai() == nextNext.getPai()) &#123; handleKezi(handPais, conditions, condition.copy(), current, next, nextNext, depth + 1); &#125; &#125; Pai currentPlusOne = current.getPai().next(false); if (currentPlusOne != null) &#123; List&lt;HandPai&gt; filtered = handPais.stream().filter(p -&gt; p.getPai() == currentPlusOne).collect(Collectors.toList()); if (filtered.size() &gt; 0) &#123; HandPai second = filtered.get(0); handleDazi(handPais, conditions, condition.copy(), current, second, depth + 1); Pai currentPlusTwo = currentPlusOne.next(false); filtered = handPais.stream().filter(p -&gt; p.getPai() == currentPlusTwo).collect(Collectors.toList()); if (filtered.size() &gt; 0) &#123; HandPai third = filtered.get(0); handleShunzi(handPais, conditions, condition.copy(), current, second, third, depth + 1); &#125; &#125; &#125; handleGuzhang(handPais, conditions, condition.copy(), current, depth + 1); current = null; next = null; nextNext = null; if (handPais.size() &lt;= 1) &#123; conditions.add(condition); &#125; return conditions; &#125; private static void handleGuzhang(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, int depth) &#123; currentHandPai = new ArrayList&lt;&gt;(currentHandPai); condition.addGuzhang(first); currentHandPai.remove(first); split(currentHandPai, conditions, condition, depth); &#125; private static void handleDazi(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, int depth) &#123; currentHandPai = new ArrayList&lt;&gt;(currentHandPai); Dazi dazi = new Dazi(Arrays.asList(first, second)); condition.addDazi(dazi); currentHandPai.remove(first); currentHandPai.remove(second); split(currentHandPai, conditions, condition, depth); &#125; private static void handleDuizi(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, int depth) &#123; currentHandPai = new ArrayList&lt;&gt;(currentHandPai); Duizi duizi = new Duizi(Arrays.asList(first, second)); condition.addDuizi(duizi); currentHandPai.remove(first); currentHandPai.remove(second); split(currentHandPai, conditions, condition, depth); &#125; private static void handleShunzi(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, HandPai third, int depth) &#123; currentHandPai = new ArrayList&lt;&gt;(currentHandPai); Shunzi shunzi = new Shunzi(Arrays.asList(first, second, third)); condition.addShunzi(shunzi); currentHandPai.remove(first); currentHandPai.remove(second); currentHandPai.remove(third); split(currentHandPai, conditions, condition, depth); &#125; private static void handleKezi(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, HandPai third, int depth) &#123; currentHandPai = new ArrayList&lt;&gt;(currentHandPai); Kezi kezi = new Kezi(Arrays.asList(first, second, third)); condition.addKezi(kezi); currentHandPai.remove(first); currentHandPai.remove(second); currentHandPai.remove(third); split(currentHandPai, conditions, condition, depth); &#125;&#125; 示例输出 1234567891011121314151617181920@Testpublic void splitDuizi() &#123; List&lt;SplitCondition&gt; split = PaiSplitter.split(\"11223344556677s\"); Assert.assertTrue(split.stream().anyMatch(c -&gt; c.getDuiziList().size() == 7));&#125;@Testpublic void testHe() &#123; List&lt;SplitCondition&gt; split = PaiSplitter.split(\"11223344556677s\"); Assert.assertTrue(split.stream().mapToInt(SplitCondition::xiangTing) .min().getAsInt() &lt; 1);&#125;@Testpublic void testKeziAndShunzi() &#123; List&lt;SplitCondition&gt; split = PaiSplitter.split(\"11155s134m579p122z\"); Assert.assertEquals(3, split.stream().mapToInt(SplitCondition::xiangTing) .min().getAsInt());&#125; 我们现在已经能够知道一副手牌的向听数了，下一期将会讲牌效率相关的内容 相关代码会在整理后放到github上","categories":[],"tags":[]},{"title":"日麻折腾笔记-01-和牌的判断","slug":"日麻折腾笔记-01-和牌的判断","date":"2019-06-10T02:27:51.000Z","updated":"2019-06-21T02:40:36.505Z","comments":true,"path":"2019/06/10/日麻折腾笔记-01-和牌的判断/","link":"","permalink":"http://blog.loli.io/2019/06/10/日麻折腾笔记-01-和牌的判断/","excerpt":"手牌和牌时的组成日本麻将除了特殊牌形（七对和国士）以外，都是 a个顺子+b个刻子+1个雀头 的形状，这里不管是门清还是非门清，都是这样。其中a、b均大于等于0。 我们可以将手牌分解成上面的形式，如果能够满足条件，则为和牌，然而手牌的组成有很多种，比如下面的手牌（九莲宝灯）： 111123455678999s 我们可以分解为1111 234 55 678 999 可以和牌 也可以分解为111 123 345 567 8 999 无法和牌 可以看到关键在于怎么对手牌中的顺子和刻子分组","text":"手牌和牌时的组成日本麻将除了特殊牌形（七对和国士）以外，都是 a个顺子+b个刻子+1个雀头 的形状，这里不管是门清还是非门清，都是这样。其中a、b均大于等于0。 我们可以将手牌分解成上面的形式，如果能够满足条件，则为和牌，然而手牌的组成有很多种，比如下面的手牌（九莲宝灯）： 111123455678999s 我们可以分解为1111 234 55 678 999 可以和牌 也可以分解为111 123 345 567 8 999 无法和牌 可以看到关键在于怎么对手牌中的顺子和刻子分组 从雀头入手不管怎么分组，手牌都要有一个雀头，所以我们先确定雀头 手牌中，数量大于等于2的牌都能作为雀头 当确定好雀头之后，就要将剩余的手牌分解为 顺子+刻子的情况，在上面的示例中，当选取5s作为雀头后，剩余的牌为 111234678999 ，我可以将 11123 认为是 111+23的形式，也可以是 11+123的形式，用程序也是比较方便实现的。 我的思路将手牌排序后，找到n个雀头 对于每个雀头，都执行下面的判断逻辑 去除雀头，得到剩余手牌P 对P按照牌进行分组后排序 对于排序后的牌，如果是连续三张牌，则将这三张牌作为一个顺子 将顺子的三张牌从P中删除 重复2-3-4步骤，直到无顺子 对P进行分组 如果某牌数量是3，则将这三张牌作为一个刻子 将刻子从P中删除 重复6-7-8步骤，直到无刻子 如果P现在无牌，则表示此时能够和牌，如果有牌，表示不能和牌 是否听牌的判断和牌和听牌不太一样，和牌是14张，听牌是13张，不管是不是门清状态，听牌必定币和牌少一张，少的是哪张牌呢？必定是下面三种情况中的其中一种 听雀头 听刻子中的一张 听顺子中的一张 也就是已有的手牌，加上上面三种中的其中一种，能够和牌，那我只需要将可能和牌的牌都列出来，每种都判断是否和牌就可以了。 对于自己的程序写的有没有问题，可以用九莲宝灯来验证一下 类的定义首先是类型的枚举，定义了万、索、筒、字四种牌123456public enum Type &#123; m, s, p, z;&#125; 一张牌是由数字+类型组成的，所以牌类如下 12345public class Pai implements Comparable&lt;Pai&gt; &#123; private Integer number; private Type type; ... getters ... setters 对于字牌，一共有东南西北中发白，七种类型，对应的number取值为1到7，在编码时还需要注意字牌是无法组成顺子的。 对于一场比赛，牌的数量类型都是早就决定好不会变的，唯一变的就是牌的顺序，我们只需定义好一个所有牌的集合，在有需要生成牌山的时候，直接将其打乱使用即可。 宝牌是否要在class Pai中定义？由于每场比赛，宝牌是变化的，与场况有关，所以不太适合放在其中。但是有一个例外——赤宝牌，我本想在Pai中增加一个属性aka/red，标示是否是赤宝牌，但想到现在只是在对手牌进行和牌、听牌的判断，增加这个字段与否和现在要解决的问题无关，索性就不管了，宝牌之类，留着后面再统一处理吧。 实际演示 相关代码会在整理后放到github上","categories":[],"tags":[]},{"title":"自制的一个爬虫nekocat","slug":"spider-01","date":"2018-06-09T12:32:29.000Z","updated":"2019-06-21T02:16:12.363Z","comments":true,"path":"2018/06/09/spider-01/","link":"","permalink":"http://blog.loli.io/2018/06/09/spider-01/","excerpt":"","text":"想法最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 https://github.com/biezhi/elves 的思路，于是就开工了，大约一两周摸鱼的时间，就基本完成了，可以来github围观：https://github.com/chocotan/nekocat，名字是随便取的。 功能 定时执行 自定义UA、代理池 支持多线程 可自定义Downloader实现headless chrome（大概） 失败重试 成果于是就找了一些网站开始爬了，注册了个域名，做了个界面，挂上了google adsense 网址：www.codetd.com","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"}]},{"title":"RxJava使用线程池","slug":"rxjava-parallel","date":"2018-03-11T05:19:47.000Z","updated":"2019-06-21T02:16:12.363Z","comments":true,"path":"2018/03/11/rxjava-parallel/","link":"","permalink":"http://blog.loli.io/2018/03/11/rxjava-parallel/","excerpt":"","text":"最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下： 12345678910// 大小为5的线程池ThreadPoolExecutor exec = new ThreadPoolExecutor( 5, 5, 200, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());Flowable.just(1, 2, 3, 4, 5) .subscribeOn(Schedulers.from(exec)) .subscribe(i -&gt; &#123; Thread.sleep(1000L); System.out.println(i + \"\\t\" + Thread.currentThread().getName()); &#125;); 由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出 123451 pool-1-thread-12 pool-1-thread-23 pool-1-thread-34 pool-1-thread-45 pool-1-thread-5 然而事与愿违，实际的输出是这样的123451 pool-1-thread-12 pool-1-thread-13 pool-1-thread-14 pool-1-thread-15 pool-1-thread-1 嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。 这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法 在flatMap中使用obseveOn 1234567Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;)) .subscribe(); 在flatMap中使用Future 12345678Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) ) .subscribe(); 使用ParallelFlowable 123456789Flowable.just(1, 2, 3, 4, 5) .parallel() .runOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) .sequential() .subscribe(); 有两个要注意的地方 RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程 parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务 后续最近发现在使用UnicastProcessor和ParallelFlowable的时候有cpu占用高的情况，经过跟踪发现是这样的问题： Flowable是支持背压的，所以在元素弹出过快的时候会抛出异常，而我又使用了retry，使得在抛出异常的时候会重新订阅Flowable，而UnicastProcessor只能被订阅一次，所以抛出了大量的IllegalStateException","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"},{"name":"rxjava","slug":"rxjava","permalink":"http://blog.loli.io/tags/rxjava/"}]},{"title":"换成Hexo了！","slug":"换成Hexo了！","date":"2016-01-28T13:36:27.000Z","updated":"2019-06-21T02:16:12.363Z","comments":true,"path":"2016/01/28/换成Hexo了！/","link":"","permalink":"http://blog.loli.io/2016/01/28/换成Hexo了！/","excerpt":"","text":"如题，看上去很不错，于是以后多发技术文 嗯嗯 test123","categories":[],"tags":[]}]}