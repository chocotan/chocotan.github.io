{"meta":{"title":"天羽ちよこ的新个人站点","subtitle":"喵！","description":"喵！","author":"天羽ちよこ","url":"http://blog.loli.io"},"pages":[],"posts":[{"title":"RxJava使用线程池","slug":"rxjava-parallel","date":"2018-03-11T05:19:47.000Z","updated":"2018-03-11T05:47:07.295Z","comments":true,"path":"2018/03/11/rxjava-parallel/","link":"","permalink":"http://blog.loli.io/2018/03/11/rxjava-parallel/","excerpt":"","text":"最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下： 12345678910// 大小为5的线程池ThreadPoolExecutor exec = new ThreadPoolExecutor( 5, 5, 200, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());Flowable.just(1, 2, 3, 4, 5) .subscribeOn(Schedulers.from(exec)) .subscribe(i -&gt; &#123; Thread.sleep(1000L); System.out.println(i + \"\\t\" + Thread.currentThread().getName()); &#125;); 由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出 123451 pool-1-thread-12 pool-1-thread-23 pool-1-thread-34 pool-1-thread-45 pool-1-thread-5 然而事与愿违，实际的输出是这样的123451 pool-1-thread-12 pool-1-thread-13 pool-1-thread-14 pool-1-thread-15 pool-1-thread-1 嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。 这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法 在flatMap中使用obseveOn 1234567Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;)) .subscribe(); 在flatMap中使用Future 12345678Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) ) .subscribe(); 使用ParallelFlowable 123456789Flowable.just(1, 2, 3, 4, 5) .parallel() .runOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) .sequential() .subscribe(); 有两个要注意的地方 RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程 parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务","categories":[],"tags":[{"name":"java,rxjava","slug":"java-rxjava","permalink":"http://blog.loli.io/tags/java-rxjava/"}]},{"title":"spring boot中@EnableXXX注解的做法","slug":"spring-boot-autoconfig-dev-01","date":"2016-11-23T13:51:00.000Z","updated":"2018-02-01T04:57:26.362Z","comments":true,"path":"2016/11/23/spring-boot-autoconfig-dev-01/","link":"","permalink":"http://blog.loli.io/2016/11/23/spring-boot-autoconfig-dev-01/","excerpt":"","text":"接触springboot也有一阵子了，之前就觉得@EnableXX的注解很酷炫，于是就简单研究了一下，可以给自己的模块加上这个功能 以下是一个简单的实现，只要在spring boot启动类上加上@EnableHello就能在启动完的时候输出”Hello Spring Boot”了 首先要有一个@EnableHello注解类 1234567891011121314151617package io.loli.demo.enable;import org.springframework.context.annotation.Import;import java.lang.annotation.*;/** * @author choco */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;HelloConfigurationSelector.class&#125;)public @interface EnableHello &#123;&#125; 这里用到了HelloConfigurationSelector 1234567891011121314package io.loli.demo.enable;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;/** * @author choco */public class HelloConfigurationSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; return new String[]&#123;HelloConfiguration.class.getName()&#125;; &#125;&#125; 这个ImportSelector接口挺有意思的，大家有兴趣可以深入研究下 123456789101112131415161718192021222324package io.loli.demo.enable;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author choco */@Configuration@ConfigurationProperties(prefix = \"hello\")public class HelloConfiguration &#123; private String message; @Bean public CommandLineRunner commandLineRunner() &#123; return args -&gt; System.out.println(message); &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 如上就是这个小工程的三个主角了，打包install之后，就可以在别的工程里用了 再新建一个Springboot工程，在启动类上添加@EnableHello注解 123456789101112131415package io.loli.demo.test;import io.loli.demo.enable.EnableHello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@EnableHellopublic class HelloTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloTestApplication.class, args); &#125;&#125; 1hello.message=Hello Spring Boot 运行这个类，就会输出hello.message中的Hello Spring Boot字符串了","categories":[],"tags":[]},{"title":"从2015到2016","slug":"2015-to-2016","date":"2016-02-25T13:46:27.000Z","updated":"2018-02-01T04:57:26.362Z","comments":true,"path":"2016/02/25/2015-to-2016/","link":"","permalink":"http://blog.loli.io/2016/02/25/2015-to-2016/","excerpt":"辞职从之前的公司辞职了，4月1日的时候入职新公司，在国内某快递公司做Java开发，微服务相关的，通俗点讲就是做接口的。嘛过的还行，除了不加班，其他没啥优势，这次年后调薪也只给我涨了15%，如果明年还是涨这么多的话可以考虑跳槽了。","text":"辞职从之前的公司辞职了，4月1日的时候入职新公司，在国内某快递公司做Java开发，微服务相关的，通俗点讲就是做接口的。嘛过的还行，除了不加班，其他没啥优势，这次年后调薪也只给我涨了15%，如果明年还是涨这么多的话可以考虑跳槽了。 买买买无聊去逛展子，发现一画风好像柚子的本子，果断买了 虎穴上看到色鸟鸟的有本子发售了，买了本回来发现主要是线稿，顺便把红鸟鸟本体和OST都买了，前两天看到第二本线稿也发售了，在masadora上面代购了 KOTOKO又来中国开live了，想起来前两次来中国没要到签名的遗憾，咬牙买了VIP票。K姐一直忙于各种live，最近几年都没有什么高质量的歌，渐渐的远离一线黄油op了，如果还有下次的话肯定是不会再买vip票了，这价格实在是太高，大概比霓虹本土的live都贵好多。离开ive后ive肯定是大力扶持自己旗下的歌姬的，不过看ive十周年live的时候发现还是k姐压轴啊….ive都没人了吗？ 大约四月的时候入了舰娘坑，成为了提督，到现在快一年了，目前提督102级了，附上一截图15年中的时候买了舰队收藏改，经历了多次跳票后终于到手了，然而玩了两个小时后的感受是：这什么破游戏？ 还买了个moto360和surface pro4买了女装（假毛和鞋子还没到 过年去了趟山东，改天再放图好了","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"http://blog.loli.io/tags/日常/"}]},{"title":"Spring Cloud学习笔记——Netflix的那些东西","slug":"spring-cloud-netflix-01","date":"2016-02-21T15:04:08.000Z","updated":"2018-02-01T04:57:26.362Z","comments":true,"path":"2016/02/21/spring-cloud-netflix-01/","link":"","permalink":"http://blog.loli.io/2016/02/21/spring-cloud-netflix-01/","excerpt":"最近微服务好像很火的样子，我司是用阿里的dubbo来搭建微服务的，最初感觉好牛叉的样子，但入职一年接触到现在的感觉是 阿里的东西bug太多了，比如我之前给fastjson提交了个非常猎奇的bug（到现在都没有回复，对阿里的好感度已经降到底了） Netflix的这些东西也是搞微服务用的，大约有这些东西Zuul、Eureka、Ribbon、Hystrix、Feign，花了一个下午整了个简单的demo。","text":"最近微服务好像很火的样子，我司是用阿里的dubbo来搭建微服务的，最初感觉好牛叉的样子，但入职一年接触到现在的感觉是 阿里的东西bug太多了，比如我之前给fastjson提交了个非常猎奇的bug（到现在都没有回复，对阿里的好感度已经降到底了） Netflix的这些东西也是搞微服务用的，大约有这些东西Zuul、Eureka、Ribbon、Hystrix、Feign，花了一个下午整了个简单的demo。 Eureka服务发现，一般是有个Eureka Server负责Client的注册，其他没啥功能，需要配合其他工具用 Server pom.xml12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; TestEurekaServerApplication.java 只需加上@EnableEurekaServer注解12345678@SpringBootApplication@EnableEurekaServerpublic class TestEurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestEurekaServerApplication.class, args); &#125;&#125; application.yml 12345678910111213141516171819## 端口server: port: 10001## 该应用名字spring: application: name: test-server## eureka server相关配置eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 启动后打开浏览器是这样的 Service我们创建一个服务给远端来调用，这个服务是需要注册到eureka的。主要配置 pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; TestEurekaServiceApplication.java创建了个url为/hello的controller方法，我们后面要做的是把这个方法暴露给远程客户端去调用 加上@EnableEurekaClient注解就能注册到Eureka了1234567891011121314151617181920212223242526272829303132@SpringBootApplication@EnableEurekaClientpublic class TestEurekaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestEurekaServiceApplication.class, args); &#125;&#125;@RestControllerclass RemoteHelloController &#123; //Eureka会自动注入注册的所有Client信息，不过并没有啥用处 @Autowired private DiscoveryClient client; @RequestMapping(\"hello\") public String hello() &#123; long start = System.currentTimeMillis(); ServiceInstance instance = client.getLocalServiceInstance(); // 随机睡眠1000毫秒以内 try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long cost = System.currentTimeMillis() - start; return \"Remote Hello~ \" + instance.getHost() + \", \" + instance.getServiceId() + \", spent \" + cost; &#125;&#125; application.yml 1234567891011eureka: client: serviceUrl: defaultZone: http://localhost:10001/eureka/spring: application: name: test-serviceserver: port: 10002 Client得有个客户端去调用注册的服务，这个客户端也是要注册到eureka的，和Service在配置上并没有啥不同 123456789101112131415161718192021222324@SpringBootApplication@EnableEurekaClientpublic class TestEurekaClientApplication &#123; public static void main(String[] args) &#123;SpringApplication.run(TestEurekaClientApplication.class, args); &#125; @Autowired HelloService helloService; @RequestMapping(\"hello\") public String hello() &#123; return helloService.hello(); &#125; @Autowired RestTemplate restTemplate; @RequestMapping(\"ribbonHello\") public String ribbonHello() &#123; return restTemplate.getForEntity(\"http://test-service/hello\", String.class).getBody(); &#125;&#125; 调用Service的方法有很多种，下面一一列出来 Ribbon1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; Ribbon是个类似于负载均衡的东西，只需要引入Ribbon的依赖，然后Ribbon就会自己创建个RestTemplate的实例了，这个RestTemplate还比较高端，和普通的不一样 比如配置文件里这样写1234## ribbon直接映射注册到eureka的服务ribbon: eureka: enabled: true 然后代码里这样写1restTemplate.getForEntity(\"http://test-service/hello\", String.class).getBody(); 调用的就是http://localhost:10002/hello了 以下是稍微完整的栗子 1234567891011121314151617@SpringBootApplication@EnableEurekaClient@RestControllerpublic class TestEurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestEurekaClientApplication.class, args); &#125; @Autowired RestTemplate restTemplate; @RequestMapping(\"ribbonHello\") public String ribbonHello() &#123; return restTemplate.getForEntity(\"http://test-service/hello\", String.class).getBody(); &#125;&#125; 如图： Zuul只要引入Zuul依赖，就会自动创建直接可以调用远程服务的mapping path 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 启动日志里会出现如下内容12016-02-21 15:41:02.741 INFO 13460 --- [pool-5-thread-1] o.s.c.n.zuul.web.ZuulHandlerMapping : Mapped URL path [/test-service/**] onto handler of type [class org.springframework.cloud.netflix.zuul.web.ZuulController] 然后打开这个url 可以自定义这个mapping path 1234zuul: ignoredServices: * routes: test-service: /test/** Zuul还可以当动态路由和反向代理来用，就不多讲了 Feign这个好像才有点远程调用的意思了，可以直接把接口映射到某个controller方法上面去，然后调用这个接口就相当于调用远程controller的方法了 12345@FeignClient(\"test-service\")interface RemoteHelloService &#123; @RequestMapping(value = \"hello\", method = RequestMethod.GET) public String remoteHello();&#125; 可以直接注入这个RemoteHelloService了1234567@AutowiredRemoteHelloService remoteHelloService;@RequestMapping(\"remoteHello\")public String remoteHello() &#123; return remoteHelloService.remoteHello();&#125; 如图 Hystrix服务调用出错或者超时的时候可以用这个来解决，还记得上面Service里的hello方法我加了不到一秒的休眠么？ 这里直接注入上面Feign的的RemoteHelloService，设置了500毫秒的超时时间，当超时的时候就fallback，去执行timeout方法 1234567891011121314151617181920@RestControllerclass RemoteHelloController &#123; @Autowired RemoteHelloService remoteHelloService; @RequestMapping(\"remoteHello\") // fallbackMethod 似乎不支持被@Configuration的Controller方法 @HystrixCommand(fallbackMethod = \"timeout\", commandProperties = &#123; @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"500\") &#125;) public String remoteHello() &#123; return remoteHelloService.remoteHello(); &#125; @HystrixCommand public String timeout() &#123; return \"Remote Timeout~\"; &#125;&#125; 如图是超时的情况 注：更多Hystrix属性见这里 Hystrix还有个dashboard，看上去很不错，这里就不介绍啦 有关Spring Cloud更多内容请看官方文档啦（很多东西文档里都没有。。）","categories":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.loli.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"}]},{"title":"Spring Cloud学习笔记——Spring Cloud Config的使用(1)","slug":"spring-cloud-01","date":"2016-01-28T16:56:13.000Z","updated":"2018-02-01T04:57:26.362Z","comments":true,"path":"2016/01/29/spring-cloud-01/","link":"","permalink":"http://blog.loli.io/2016/01/29/spring-cloud-01/","excerpt":"最近迷上了Spring Cloud，动态路由、负载均衡、服务发现，各种功能，觉得可以替换我司目前使用的任务调度和微服务了，我司任务调度用的是tb-schedule(基于zookeeper)，微服务是自己用dubbo实现的。 实际开发中对于任务分片用的很少，而是对于查询出数据后，如何高效地处理这些数据的问题。tb-schedule想要多线程的话，只能配置多个任务项，导致查询数据的时候必须根据任务项去区分开来。","text":"最近迷上了Spring Cloud，动态路由、负载均衡、服务发现，各种功能，觉得可以替换我司目前使用的任务调度和微服务了，我司任务调度用的是tb-schedule(基于zookeeper)，微服务是自己用dubbo实现的。 实际开发中对于任务分片用的很少，而是对于查询出数据后，如何高效地处理这些数据的问题。tb-schedule想要多线程的话，只能配置多个任务项，导致查询数据的时候必须根据任务项去区分开来。 123456-- 线程0，查询出来处理select * from tab01 where flag=0-- 线程1，查询出来处理select * from tab01 where flag=1-- 线程2，查询出来处理select * from tab01 where flag=2 而我想要的并不是查询时分多个线程，而是一起查询，多线程去处理。 于是自己想开发一个任务调度框架了，不过先要熟悉一下spring cloud到底有哪些内容，于是照着英文文档围观了一下 ##spring-cloud-config-server如果配置是写死在xml或者properties文件里，且需要修改这个配置的时候，咋办？停掉修改打包上传么？用了这个config-server的话，可以不需要改代码方便的修改配置了 pom.xml中增加如下依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 1234567@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; application.yml 123456789101112server: port: 8888management: context-path: /adminspring: cloud: config: server: git: uri: /home/choco/soft/gittest/ spring-cloud-config是用git作为配置仓库的，git.url可以是本地的git目录，也可以是远程的git目录，会自动加载该目录下的properties文件， 我的git仓库里有test.properties12choco.name=chocotanchoco.password=123456 启动后打开浏览器http://localhost:8888/test/master大约是这样的格式 [ip:address]/[filename]/[branch]返回 12345678910111213&#123; \"name\": \"test\", \"profiles\": [\"master\"], \"label\": null, \"version\": \"2ab9d0ab4f9d88e0eed31702e038d9ec11d7ae16\", \"propertySources\": [&#123; \"name\": \"/home/choco/soft/gittest/test.properties\", \"source\": &#123; \"choco.password\": \"123456\", \"choco.name\": \"chocotan\" &#125; &#125;]&#125; 嗯 大约完成config-server的配置了","categories":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.loli.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"}]},{"title":"换成Hexo了！","slug":"换成Hexo了！","date":"2016-01-28T13:36:27.000Z","updated":"2018-02-01T04:57:26.362Z","comments":true,"path":"2016/01/28/换成Hexo了！/","link":"","permalink":"http://blog.loli.io/2016/01/28/换成Hexo了！/","excerpt":"","text":"如题，看上去很不错，于是以后多发技术文 嗯嗯 test123","categories":[],"tags":[]}]}