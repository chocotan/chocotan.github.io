{"meta":{"title":"天羽ちよこ的新个人站点","subtitle":"喵！","description":"喵！","author":"天羽ちよこ","url":"http://blog.loli.io"},"pages":[],"posts":[{"title":"日麻折腾笔记-03-向听数和有效牌","slug":"日麻折腾笔记-03-向听数和有效牌","date":"2019-06-10T02:28:43.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2019/06/10/日麻折腾笔记-03-向听数和有效牌/","link":"","permalink":"http://blog.loli.io/2019/06/10/日麻折腾笔记-03-向听数和有效牌/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"日麻折腾笔记-02-听牌的判断","slug":"日麻折腾笔记-02-听牌的判断","date":"2019-06-10T02:28:30.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2019/06/10/日麻折腾笔记-02-听牌的判断/","link":"","permalink":"http://blog.loli.io/2019/06/10/日麻折腾笔记-02-听牌的判断/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"日麻折腾笔记-01-和牌的判断","slug":"日麻折腾笔记-01-和牌的判断","date":"2019-06-10T02:27:51.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2019/06/10/日麻折腾笔记-01-和牌的判断/","link":"","permalink":"http://blog.loli.io/2019/06/10/日麻折腾笔记-01-和牌的判断/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"自制的一个爬虫nekocat","slug":"spider-01","date":"2018-06-09T12:32:29.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2018/06/09/spider-01/","link":"","permalink":"http://blog.loli.io/2018/06/09/spider-01/","excerpt":"","text":"想法最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 https://github.com/biezhi/elves 的思路，于是就开工了，大约一两周摸鱼的时间，就基本完成了，可以来github围观：https://github.com/chocotan/nekocat，名字是随便取的。 功能 定时执行 自定义UA、代理池 支持多线程 可自定义Downloader实现headless chrome（大概） 失败重试 成果于是就找了一些网站开始爬了，注册了个域名，做了个界面，挂上了google adsense 网址：www.codetd.com","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"}]},{"title":"RxJava使用线程池","slug":"rxjava-parallel","date":"2018-03-11T05:19:47.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2018/03/11/rxjava-parallel/","link":"","permalink":"http://blog.loli.io/2018/03/11/rxjava-parallel/","excerpt":"","text":"最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下： 12345678910// 大小为5的线程池ThreadPoolExecutor exec = new ThreadPoolExecutor( 5, 5, 200, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());Flowable.just(1, 2, 3, 4, 5) .subscribeOn(Schedulers.from(exec)) .subscribe(i -&gt; &#123; Thread.sleep(1000L); System.out.println(i + \"\\t\" + Thread.currentThread().getName()); &#125;); 由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出 123451 pool-1-thread-12 pool-1-thread-23 pool-1-thread-34 pool-1-thread-45 pool-1-thread-5 然而事与愿违，实际的输出是这样的123451 pool-1-thread-12 pool-1-thread-13 pool-1-thread-14 pool-1-thread-15 pool-1-thread-1 嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。 这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法 在flatMap中使用obseveOn 1234567Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;)) .subscribe(); 在flatMap中使用Future 12345678Flowable.just(1, 2, 3, 4, 5) .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) ) .subscribe(); 使用ParallelFlowable 123456789Flowable.just(1, 2, 3, 4, 5) .parallel() .runOn(Schedulers.from(exec)) .doOnNext(d -&gt; &#123; System.out.println(d + \"\\t\" + Thread.currentThread().getName()); Thread.sleep(1000L); &#125;) .sequential() .subscribe(); 有两个要注意的地方 RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程 parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务 后续最近发现在使用UnicastProcessor和ParallelFlowable的时候有cpu占用高的情况，经过跟踪发现是这样的问题： Flowable是支持背压的，所以在元素弹出过快的时候会抛出异常，而我又使用了retry，使得在抛出异常的时候会重新订阅Flowable，而UnicastProcessor只能被订阅一次，所以抛出了大量的IllegalStateException","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.loli.io/tags/java/"},{"name":"rxjava","slug":"rxjava","permalink":"http://blog.loli.io/tags/rxjava/"}]},{"title":"换成Hexo了！","slug":"换成Hexo了！","date":"2016-01-28T13:36:27.000Z","updated":"2019-06-10T02:51:18.476Z","comments":true,"path":"2016/01/28/换成Hexo了！/","link":"","permalink":"http://blog.loli.io/2016/01/28/换成Hexo了！/","excerpt":"","text":"如题，看上去很不错，于是以后多发技术文 嗯嗯 test123","categories":[],"tags":[]}]}