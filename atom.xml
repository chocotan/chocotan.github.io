<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天羽ちよこ的新个人站点</title>
  <icon>https://www.gravatar.com/avatar/ef658c7a3740ff7e955b6e77ae145cd7</icon>
  <subtitle>喵！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.loli.io/"/>
  <updated>2019-06-23T09:27:50.000Z</updated>
  <id>http://blog.loli.io/</id>
  
  <author>
    <name>天羽ちよこ</name>
    <email>loli@linux.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日麻折腾笔记-02-向听数的判断</title>
    <link href="http://blog.loli.io/2019/06/22/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-02-%E5%90%91%E5%90%AC%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://blog.loli.io/2019/06/22/日麻折腾笔记-02-向听数的判断/</id>
    <published>2019-06-22T01:05:16.000Z</published>
    <updated>2019-06-23T09:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>向听数比较通俗易懂的解释是还差几张牌听牌，用程序能理解的话就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将手牌的n张牌替换成任意一张牌，能够满足听牌的n的最小值</span><br><span class="line">此时，手牌就是n向听</span><br></pre></td></tr></table></figure></p><p>向听数可以由下面的公式快速算出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向听数=8-2x(顺子数量+刻子数量)-对子数量-搭子数量</span><br></pre></td></tr></table></figure></p><blockquote><p>暂不考虑七对子与国士无双</p></blockquote><p>所以只需要算出顺子、刻子、对子以及搭子的数量即可</p><p>但是要注意的是，很多牌形是有多种拆分方式的，诸如下面的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234s</span><br></pre></td></tr></table></figure></p><p>可以认为是<code>123</code>的顺子加上孤张<code>4</code>，也可以认为是<code>1</code>的孤张加上<code>234</code>的顺子，还可以认为是<code>12</code>和<code>34</code>两个搭子……</p><a id="more"></a><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我完善了上一章中的代码，将对子、刻子、顺子等概念抽象成类，每种拆分情况都由这四种组成，部分示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.loli.mj.util.analyze;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.loli.mj.util.HandPai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手牌分解的每种组合</span></span><br><span class="line"><span class="comment"> * 每种组合都由a个顺子、b个刻子、c个对子、d个搭子、e个孤张组合而成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Duizi&gt; duiziList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Shunzi&gt; shunziList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Dazi&gt; daziList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Kezi&gt; keziList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;HandPai&gt; guzhangList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xiangTing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span> - <span class="number">2</span> * (keziList.size() + shunziList.size()) - daziList.size() - duiziList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDuizi</span><span class="params">(Duizi duizi)</span> </span>&#123;</span><br><span class="line">        duiziList.add(duizi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addShunzi</span><span class="params">(Shunzi shunzi)</span> </span>&#123;</span><br><span class="line">        shunziList.add(shunzi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDazi</span><span class="params">(Dazi dazi)</span> </span>&#123;</span><br><span class="line">        daziList.add(dazi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKezi</span><span class="params">(Kezi kezi)</span> </span>&#123;</span><br><span class="line">        keziList.add(kezi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addGuzhang</span><span class="params">(HandPai guzhang)</span> </span>&#123;</span><br><span class="line">        guzhangList.add(guzhang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Duizi&gt; <span class="title">getDuiziList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duiziList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Shunzi&gt; <span class="title">getShunziList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shunziList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dazi&gt; <span class="title">getDaziList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> daziList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Kezi&gt; <span class="title">getKeziList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keziList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;HandPai&gt; <span class="title">getGuzhangList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> guzhangList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGuzhangList</span><span class="params">(List&lt;HandPai&gt; guzhangList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.guzhangList = guzhangList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SplitCondition <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SplitCondition condition = <span class="keyword">new</span> SplitCondition();</span><br><span class="line">        condition.duiziList = <span class="keyword">new</span> ArrayList&lt;&gt;(getDuiziList());</span><br><span class="line">        condition.daziList = <span class="keyword">new</span> ArrayList&lt;&gt;(getDaziList());</span><br><span class="line">        condition.keziList = <span class="keyword">new</span> ArrayList&lt;&gt;(getKeziList());</span><br><span class="line">        condition.shunziList = <span class="keyword">new</span> ArrayList&lt;&gt;(getShunziList());</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> +</span><br><span class="line">                duiziList +</span><br><span class="line">                shunziList +</span><br><span class="line">                daziList +</span><br><span class="line">                keziList +</span><br><span class="line">                guzhangList + <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.loli.mj.util.analyze;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.loli.mj.util.HandAnalyze;</span><br><span class="line"><span class="keyword">import</span> io.loli.mj.util.HandPai;</span><br><span class="line"><span class="keyword">import</span> io.loli.mj.util.Pai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaiSplitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;SplitCondition&gt; <span class="title">split</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        List&lt;HandPai&gt; handPais = HandAnalyze.strToHandPai(str);</span><br><span class="line">        List&lt;SplitCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> split(handPais, conditions, <span class="keyword">new</span> SplitCondition(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;SplitCondition&gt; <span class="title">split</span><span class="params">(List&lt;HandPai&gt; handPais, List&lt;SplitCondition&gt; conditions, SplitCondition condition, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handPais.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            conditions.add(condition);</span><br><span class="line">            <span class="keyword">return</span> conditions;</span><br><span class="line">        &#125;</span><br><span class="line">        HandPai current = <span class="keyword">null</span>;</span><br><span class="line">        HandPai next = <span class="keyword">null</span>;</span><br><span class="line">        HandPai nextNext = <span class="keyword">null</span>;</span><br><span class="line">        current = handPais.get(<span class="number">0</span>);</span><br><span class="line">        next = handPais.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != handPais.size() - <span class="number">2</span>) &#123;</span><br><span class="line">            nextNext = handPais.get(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理对子</span></span><br><span class="line">        <span class="keyword">if</span> (current.getPai() == next.getPai()) &#123;</span><br><span class="line">            handleDuizi(handPais, conditions, condition.copy(), current, next, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理刻子</span></span><br><span class="line">        <span class="keyword">if</span> (nextNext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.getPai() == next.getPai() &amp;&amp; next.getPai() == nextNext.getPai()) &#123;</span><br><span class="line">                handleKezi(handPais, conditions, condition.copy(), current, next, nextNext, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Pai currentPlusOne = current.getPai().next(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentPlusOne != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;HandPai&gt; filtered = handPais.stream().filter(p -&gt; p.getPai() == currentPlusOne).collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">if</span> (filtered.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                HandPai second = filtered.get(<span class="number">0</span>);</span><br><span class="line">                handleDazi(handPais, conditions, condition.copy(), current, second, depth + <span class="number">1</span>);</span><br><span class="line">                Pai currentPlusTwo = currentPlusOne.next(<span class="keyword">false</span>);</span><br><span class="line">                filtered = handPais.stream().filter(p -&gt; p.getPai() == currentPlusTwo).collect(Collectors.toList());</span><br><span class="line">                <span class="keyword">if</span> (filtered.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    HandPai third = filtered.get(<span class="number">0</span>);</span><br><span class="line">                    handleShunzi(handPais, conditions, condition.copy(), current, second, third, depth + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleGuzhang(handPais, conditions, condition.copy(), current, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> conditions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleGuzhang</span><span class="params">(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        currentHandPai = <span class="keyword">new</span> ArrayList&lt;&gt;(currentHandPai);</span><br><span class="line">        condition.addGuzhang(first);</span><br><span class="line">        currentHandPai.remove(first);</span><br><span class="line">        split(currentHandPai, conditions, condition, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleDazi</span><span class="params">(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        currentHandPai = <span class="keyword">new</span> ArrayList&lt;&gt;(currentHandPai);</span><br><span class="line">        Dazi dazi = <span class="keyword">new</span> Dazi(Arrays.asList(first, second));</span><br><span class="line">        condition.addDazi(dazi);</span><br><span class="line">        currentHandPai.remove(first);</span><br><span class="line">        currentHandPai.remove(second);</span><br><span class="line">        split(currentHandPai, conditions, condition, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleDuizi</span><span class="params">(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        currentHandPai = <span class="keyword">new</span> ArrayList&lt;&gt;(currentHandPai);</span><br><span class="line">        Duizi duizi = <span class="keyword">new</span> Duizi(Arrays.asList(first, second));</span><br><span class="line">        condition.addDuizi(duizi);</span><br><span class="line">        currentHandPai.remove(first);</span><br><span class="line">        currentHandPai.remove(second);</span><br><span class="line">        split(currentHandPai, conditions, condition, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleShunzi</span><span class="params">(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     HandPai third, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        currentHandPai = <span class="keyword">new</span> ArrayList&lt;&gt;(currentHandPai);</span><br><span class="line">        Shunzi shunzi = <span class="keyword">new</span> Shunzi(Arrays.asList(first, second, third));</span><br><span class="line">        condition.addShunzi(shunzi);</span><br><span class="line">        currentHandPai.remove(first);</span><br><span class="line">        currentHandPai.remove(second);</span><br><span class="line">        currentHandPai.remove(third);</span><br><span class="line">        split(currentHandPai, conditions, condition, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleKezi</span><span class="params">(List&lt;HandPai&gt; currentHandPai, List&lt;SplitCondition&gt; conditions, SplitCondition condition, HandPai first, HandPai second,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   HandPai third, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        currentHandPai = <span class="keyword">new</span> ArrayList&lt;&gt;(currentHandPai);</span><br><span class="line">        Kezi kezi = <span class="keyword">new</span> Kezi(Arrays.asList(first, second, third));</span><br><span class="line">        condition.addKezi(kezi);</span><br><span class="line">        currentHandPai.remove(first);</span><br><span class="line">        currentHandPai.remove(second);</span><br><span class="line">        currentHandPai.remove(third);</span><br><span class="line">        split(currentHandPai, conditions, condition, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitDuizi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SplitCondition&gt; split = PaiSplitter.split(<span class="string">"11223344556677s"</span>);</span><br><span class="line">    Assert.assertTrue(split.stream().anyMatch(c -&gt; c.getDuiziList().size() == <span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SplitCondition&gt; split = PaiSplitter.split(<span class="string">"11223344556677s"</span>);</span><br><span class="line">    Assert.assertTrue(split.stream().mapToInt(SplitCondition::xiangTing)</span><br><span class="line">            .min().getAsInt() &lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKeziAndShunzi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SplitCondition&gt; split = PaiSplitter.split(<span class="string">"11155s134m579p122z"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">3</span>, split.stream().mapToInt(SplitCondition::xiangTing)</span><br><span class="line">            .min().getAsInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在已经能够知道一副手牌的向听数了，下一期将会讲牌效率相关的内容</p><blockquote><p>相关代码会在整理后放到github上</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p&gt;向听数比较通俗易懂的解释是还差几张牌听牌，用程序能理解的话就是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;将手牌的n张牌替换成任意一张牌，能够满足听牌的n的最小值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此时，手牌就是n向听&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;向听数可以由下面的公式快速算出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;向听数=8-2x(顺子数量+刻子数量)-对子数量-搭子数量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;暂不考虑七对子与国士无双&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以只需要算出顺子、刻子、对子以及搭子的数量即可&lt;/p&gt;
&lt;p&gt;但是要注意的是，很多牌形是有多种拆分方式的，诸如下面的示例&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1234s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以认为是&lt;code&gt;123&lt;/code&gt;的顺子加上孤张&lt;code&gt;4&lt;/code&gt;，也可以认为是&lt;code&gt;1&lt;/code&gt;的孤张加上&lt;code&gt;234&lt;/code&gt;的顺子，还可以认为是&lt;code&gt;12&lt;/code&gt;和&lt;code&gt;34&lt;/code&gt;两个搭子……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日麻折腾笔记-01-和牌的判断</title>
    <link href="http://blog.loli.io/2019/06/10/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-01-%E5%92%8C%E7%89%8C%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://blog.loli.io/2019/06/10/日麻折腾笔记-01-和牌的判断/</id>
    <published>2019-06-10T02:27:51.000Z</published>
    <updated>2019-06-21T02:40:36.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手牌和牌时的组成"><a href="#手牌和牌时的组成" class="headerlink" title="手牌和牌时的组成"></a>手牌和牌时的组成</h2><p>日本麻将除了特殊牌形（七对和国士）以外，都是 <code>a个顺子+b个刻子+1个雀头</code> 的形状，这里不管是门清还是非门清，都是这样。其中a、b均大于等于0。</p><p>我们可以将手牌分解成上面的形式，如果能够满足条件，则为和牌，然而手牌的组成有很多种，比如下面的手牌（九莲宝灯）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11123455678999s</span><br></pre></td></tr></table></figure><p>我们可以分解为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111 234 55 678 999</span><br></pre></td></tr></table></figure></p><p>可以和牌</p><p>也可以分解为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 123 345 567 8 999</span><br></pre></td></tr></table></figure></p><p>无法和牌</p><p>可以看到关键在于怎么对手牌中的顺子和刻子分组<br><a id="more"></a></p><h2 id="从雀头入手"><a href="#从雀头入手" class="headerlink" title="从雀头入手"></a>从雀头入手</h2><p>不管怎么分组，手牌都要有一个<code>雀头</code>，所以我们先确定雀头</p><p>手牌中，数量大于等于2的牌都能作为雀头</p><p>当确定好雀头之后，就要将剩余的手牌分解为 顺子+刻子的情况，在上面的示例中，当选取5s作为雀头后，剩余的牌为 111234678999 ，我可以将 11123 认为是 111+23的形式，也可以是 11+123的形式，用程序也是比较方便实现的。</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>将手牌排序后，找到n个雀头</p><p>对于每个雀头，都执行下面的判断逻辑</p><ol><li>去除雀头，得到剩余手牌P</li><li>对P按照牌进行分组后排序</li><li>对于排序后的牌，如果是连续三张牌，则将这三张牌作为一个顺子</li><li>将顺子的三张牌从P中删除</li><li>重复2-3-4步骤，直到无顺子</li><li>对P进行分组</li><li>如果某牌数量是3，则将这三张牌作为一个刻子</li><li>将刻子从P中删除</li><li>重复6-7-8步骤，直到无刻子</li><li>如果P现在无牌，则表示此时能够和牌，如果有牌，表示不能和牌</li></ol><h2 id="是否听牌的判断"><a href="#是否听牌的判断" class="headerlink" title="是否听牌的判断"></a>是否听牌的判断</h2><p>和牌和听牌不太一样，和牌是14张，听牌是13张，不管是不是门清状态，听牌必定币和牌少一张，少的是哪张牌呢？必定是下面三种情况中的其中一种</p><ol><li>听雀头</li><li>听刻子中的一张</li><li>听顺子中的一张</li></ol><p>也就是已有的手牌，加上上面三种中的其中一种，能够和牌，那我只需要将可能和牌的牌都列出来，每种都判断是否和牌就可以了。</p><p>对于自己的程序写的有没有问题，可以用九莲宝灯来验证一下</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>首先是类型的枚举，定义了万、索、筒、字四种牌<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    m,</span><br><span class="line">    s,</span><br><span class="line">    p,</span><br><span class="line">    z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一张牌是由数字+类型组成的，所以牌类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pai</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pai</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">    ... getters</span><br><span class="line">    ... setters</span><br></pre></td></tr></table></figure><p>对于字牌，一共有东南西北中发白，七种类型，对应的number取值为1到7，在编码时还需要注意字牌是无法组成顺子的。</p><p>对于一场比赛，牌的数量类型都是早就决定好不会变的，唯一变的就是牌的顺序，我们只需定义好一个所有牌的集合，在有需要生成牌山的时候，直接将其打乱使用即可。</p><p>宝牌是否要在<code>class Pai</code>中定义？由于每场比赛，宝牌是变化的，与场况有关，所以不太适合放在其中。但是有一个例外——赤宝牌，我本想在Pai中增加一个属性aka/red，标示是否是赤宝牌，但想到现在只是在对手牌进行和牌、听牌的判断，增加这个字段与否和现在要解决的问题无关，索性就不管了，宝牌之类，留着后面再统一处理吧。</p><h2 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h2><p><img src="https://b1.loli.io/images/GjMLe.png" alt="image.png"></p><blockquote><p>相关代码会在整理后放到github上</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;手牌和牌时的组成&quot;&gt;&lt;a href=&quot;#手牌和牌时的组成&quot; class=&quot;headerlink&quot; title=&quot;手牌和牌时的组成&quot;&gt;&lt;/a&gt;手牌和牌时的组成&lt;/h2&gt;&lt;p&gt;日本麻将除了特殊牌形（七对和国士）以外，都是 &lt;code&gt;a个顺子+b个刻子+1个雀头&lt;/code&gt; 的形状，这里不管是门清还是非门清，都是这样。其中a、b均大于等于0。&lt;/p&gt;
&lt;p&gt;我们可以将手牌分解成上面的形式，如果能够满足条件，则为和牌，然而手牌的组成有很多种，比如下面的手牌（九莲宝灯）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;11123455678999s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以分解为&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;111 234 55 678 999&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以和牌&lt;/p&gt;
&lt;p&gt;也可以分解为&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;11 123 345 567 8 999&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;无法和牌&lt;/p&gt;
&lt;p&gt;可以看到关键在于怎么对手牌中的顺子和刻子分组&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制的一个爬虫nekocat</title>
    <link href="http://blog.loli.io/2018/06/09/spider-01/"/>
    <id>http://blog.loli.io/2018/06/09/spider-01/</id>
    <published>2018-06-09T12:32:29.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 <a href="https://github.com/biezhi/elves" target="_blank" rel="noopener">https://github.com/biezhi/elves</a> 的思路，于是就开工了，大约一两周摸鱼的时间，就基本完成了，可以来github围观：<a href="https://github.com/chocotan/nekocat" target="_blank" rel="noopener">https://github.com/chocotan/nekocat</a><br>，名字是随便取的。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定时执行</li><li>自定义UA、代理池</li><li>支持多线程</li><li>可自定义Downloader实现headless chrome（大概）</li><li>失败重试</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>于是就找了一些网站开始爬了，注册了个域名，做了个界面，挂上了google adsense</p><p>网址：<a href="http://www.codetd.com" target="_blank" rel="noopener">www.codetd.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h2&gt;&lt;p&gt;最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 &lt;a href=&quot;https://git
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RxJava使用线程池</title>
    <link href="http://blog.loli.io/2018/03/11/rxjava-parallel/"/>
    <id>http://blog.loli.io/2018/03/11/rxjava-parallel/</id>
    <published>2018-03-11T05:19:47.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为5的线程池</span></span><br><span class="line">ThreadPoolExecutor exec = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="number">5</span>, <span class="number">200</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .subscribeOn(Schedulers.from(exec))</span><br><span class="line">        .subscribe(i -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            System.out.println(i + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-2</span><br><span class="line">3pool-1-thread-3</span><br><span class="line">4pool-1-thread-4</span><br><span class="line">5pool-1-thread-5</span><br></pre></td></tr></table></figure><p>然而事与愿违，实际的输出是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-1</span><br><span class="line">3pool-1-thread-1</span><br><span class="line">4pool-1-thread-1</span><br><span class="line">5pool-1-thread-1</span><br></pre></td></tr></table></figure></p><p>嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。</p><p>这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法</p><ol><li><p>在flatMap中使用obseveOn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;))</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>在flatMap中使用Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">        )</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>使用ParallelFlowable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .runOn(Schedulers.from(exec))</span><br><span class="line">        .doOnNext(d -&gt; &#123;</span><br><span class="line">            System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .sequential()</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li></ol><p>有两个要注意的地方</p><ol><li>RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程</li><li>parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>最近发现在使用UnicastProcessor和ParallelFlowable的时候有cpu占用高的情况，经过跟踪发现是这样的问题：</p><p>Flowable是支持背压的，所以在元素弹出过快的时候会抛出异常，而我又使用了retry，使得在抛出异常的时候会重新订阅Flowable，而UnicastProcessor只能被订阅一次，所以抛出了大量的IllegalStateException</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
      <category term="rxjava" scheme="http://blog.loli.io/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>换成Hexo了！</title>
    <link href="http://blog.loli.io/2016/01/28/%E6%8D%A2%E6%88%90Hexo%E4%BA%86%EF%BC%81/"/>
    <id>http://blog.loli.io/2016/01/28/换成Hexo了！/</id>
    <published>2016-01-28T13:36:27.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>如题，看上去很不错，于是以后多发技术文</p><p>嗯嗯</p><p>test123</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，看上去很不错，于是以后多发技术文&lt;/p&gt;
&lt;p&gt;嗯嗯&lt;/p&gt;
&lt;p&gt;test123&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
