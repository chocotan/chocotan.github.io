<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天羽ちよこ的新个人站点</title>
  <icon>https://www.gravatar.com/avatar/ef658c7a3740ff7e955b6e77ae145cd7</icon>
  <subtitle>喵！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.loli.io/"/>
  <updated>2019-06-10T02:51:18.476Z</updated>
  <id>http://blog.loli.io/</id>
  
  <author>
    <name>天羽ちよこ</name>
    <email>loli@linux.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日麻折腾笔记-03-向听数和有效牌</title>
    <link href="http://blog.loli.io/2019/06/10/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-03-%E5%90%91%E5%90%AC%E6%95%B0%E5%92%8C%E6%9C%89%E6%95%88%E7%89%8C/"/>
    <id>http://blog.loli.io/2019/06/10/日麻折腾笔记-03-向听数和有效牌/</id>
    <published>2019-06-10T02:28:43.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日麻折腾笔记-02-听牌的判断</title>
    <link href="http://blog.loli.io/2019/06/10/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-02-%E5%90%AC%E7%89%8C%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://blog.loli.io/2019/06/10/日麻折腾笔记-02-听牌的判断/</id>
    <published>2019-06-10T02:28:30.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日麻折腾笔记-01-和牌的判断</title>
    <link href="http://blog.loli.io/2019/06/10/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-01-%E5%92%8C%E7%89%8C%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://blog.loli.io/2019/06/10/日麻折腾笔记-01-和牌的判断/</id>
    <published>2019-06-10T02:27:51.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制的一个爬虫nekocat</title>
    <link href="http://blog.loli.io/2018/06/09/spider-01/"/>
    <id>http://blog.loli.io/2018/06/09/spider-01/</id>
    <published>2018-06-09T12:32:29.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 <a href="https://github.com/biezhi/elves" target="_blank" rel="noopener">https://github.com/biezhi/elves</a> 的思路，于是就开工了，大约一两周摸鱼的时间，就基本完成了，可以来github围观：<a href="https://github.com/chocotan/nekocat" target="_blank" rel="noopener">https://github.com/chocotan/nekocat</a><br>，名字是随便取的。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定时执行</li><li>自定义UA、代理池</li><li>支持多线程</li><li>可自定义Downloader实现headless chrome（大概）</li><li>失败重试</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>于是就找了一些网站开始爬了，注册了个域名，做了个界面，挂上了google adsense</p><p>网址：<a href="http://www.codetd.com" target="_blank" rel="noopener">www.codetd.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h2&gt;&lt;p&gt;最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 &lt;a href=&quot;https://git
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RxJava使用线程池</title>
    <link href="http://blog.loli.io/2018/03/11/rxjava-parallel/"/>
    <id>http://blog.loli.io/2018/03/11/rxjava-parallel/</id>
    <published>2018-03-11T05:19:47.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <content type="html"><![CDATA[<p>最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为5的线程池</span></span><br><span class="line">ThreadPoolExecutor exec = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="number">5</span>, <span class="number">200</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .subscribeOn(Schedulers.from(exec))</span><br><span class="line">        .subscribe(i -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            System.out.println(i + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-2</span><br><span class="line">3pool-1-thread-3</span><br><span class="line">4pool-1-thread-4</span><br><span class="line">5pool-1-thread-5</span><br></pre></td></tr></table></figure><p>然而事与愿违，实际的输出是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-1</span><br><span class="line">3pool-1-thread-1</span><br><span class="line">4pool-1-thread-1</span><br><span class="line">5pool-1-thread-1</span><br></pre></td></tr></table></figure></p><p>嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。</p><p>这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法</p><ol><li><p>在flatMap中使用obseveOn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;))</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>在flatMap中使用Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">        )</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>使用ParallelFlowable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .runOn(Schedulers.from(exec))</span><br><span class="line">        .doOnNext(d -&gt; &#123;</span><br><span class="line">            System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .sequential()</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li></ol><p>有两个要注意的地方</p><ol><li>RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程</li><li>parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>最近发现在使用UnicastProcessor和ParallelFlowable的时候有cpu占用高的情况，经过跟踪发现是这样的问题：</p><p>Flowable是支持背压的，所以在元素弹出过快的时候会抛出异常，而我又使用了retry，使得在抛出异常的时候会重新订阅Flowable，而UnicastProcessor只能被订阅一次，所以抛出了大量的IllegalStateException</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
      <category term="rxjava" scheme="http://blog.loli.io/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>换成Hexo了！</title>
    <link href="http://blog.loli.io/2016/01/28/%E6%8D%A2%E6%88%90Hexo%E4%BA%86%EF%BC%81/"/>
    <id>http://blog.loli.io/2016/01/28/换成Hexo了！/</id>
    <published>2016-01-28T13:36:27.000Z</published>
    <updated>2019-06-10T02:51:18.476Z</updated>
    
    <content type="html"><![CDATA[<p>如题，看上去很不错，于是以后多发技术文</p><p>嗯嗯</p><p>test123</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，看上去很不错，于是以后多发技术文&lt;/p&gt;
&lt;p&gt;嗯嗯&lt;/p&gt;
&lt;p&gt;test123&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
