<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天羽ちよこ的新个人站点</title>
  <icon>https://www.gravatar.com/avatar/ef658c7a3740ff7e955b6e77ae145cd7</icon>
  <subtitle>喵！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.loli.io/"/>
  <updated>2019-06-21T02:37:13.089Z</updated>
  <id>http://blog.loli.io/</id>
  
  <author>
    <name>天羽ちよこ</name>
    <email>loli@linux.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日麻折腾笔记-01-和牌的判断</title>
    <link href="http://blog.loli.io/2019/06/10/%E6%97%A5%E9%BA%BB%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-01-%E5%92%8C%E7%89%8C%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://blog.loli.io/2019/06/10/日麻折腾笔记-01-和牌的判断/</id>
    <published>2019-06-10T02:27:51.000Z</published>
    <updated>2019-06-21T02:37:13.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手牌和牌时的组成"><a href="#手牌和牌时的组成" class="headerlink" title="手牌和牌时的组成"></a>手牌和牌时的组成</h2><p>日本麻将除了特殊牌形（七对和国士）以外，都是 <code>a个顺子+b个刻子+1个雀头</code> 的形状，这里不管是门清还是非门清，都是这样。其中a、b均大于等于0。</p><p>我们可以将手牌分解成上面的形式，如果能够满足条件，则为和牌，然而手牌的组成有很多种，比如下面的手牌（九莲宝灯）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11123455678999s</span><br></pre></td></tr></table></figure><p>我们可以分解为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111 234 55 678 999</span><br></pre></td></tr></table></figure></p><p>可以和牌</p><p>也可以分解为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 123 345 567 8 999</span><br></pre></td></tr></table></figure></p><p>无法和牌</p><p>可以看到关键在于怎么对手牌中的顺子和刻子分组<br><!--readmore--></p><h2 id="从雀头入手"><a href="#从雀头入手" class="headerlink" title="从雀头入手"></a>从雀头入手</h2><p>不管怎么分组，手牌都要有一个<code>雀头</code>，所以我们先确定雀头</p><p>手牌中，数量大于等于2的牌都能作为雀头</p><p>当确定好雀头之后，就要将剩余的手牌分解为 顺子+刻子的情况，在上面的示例中，当选取5s作为雀头后，剩余的牌为 111234678999 ，我可以将 11123 认为是 111+23的形式，也可以是 11+123的形式，用程序也是比较方便实现的。</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>将手牌排序后，找到n个雀头</p><p>对于每个雀头，都执行下面的判断逻辑</p><ol><li>去除雀头，得到剩余手牌P</li><li>对P按照牌进行分组后排序</li><li>对于排序后的牌，如果是连续三张牌，则将这三张牌作为一个顺子</li><li>将顺子的三张牌从P中删除</li><li>重复2-3-4步骤，直到无顺子</li><li>对P进行分组</li><li>如果某牌数量是3，则将这三张牌作为一个刻子</li><li>将刻子从P中删除</li><li>重复6-7-8步骤，直到无刻子</li><li>如果P现在无牌，则表示此时能够和牌，如果有牌，表示不能和牌</li></ol><h2 id="是否听牌的判断"><a href="#是否听牌的判断" class="headerlink" title="是否听牌的判断"></a>是否听牌的判断</h2><p>和牌和听牌不太一样，和牌是14张，听牌是13张，不管是不是门清状态，听牌必定币和牌少一张，少的是哪张牌呢？必定是下面三种情况中的其中一种</p><ol><li>听雀头</li><li>听刻子中的一张</li><li>听顺子中的一张</li></ol><p>也就是已有的手牌，加上上面三种中的其中一种，能够和牌，那我只需要将可能和牌的牌都列出来，每种都判断是否和牌就可以了。</p><p>对于自己的程序写的有没有问题，可以用九莲宝灯来验证一下</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>首先是类型的枚举，定义了万、索、筒、字四种牌<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    m,</span><br><span class="line">    s,</span><br><span class="line">    p,</span><br><span class="line">    z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一张牌是由数字+类型组成的，所以牌类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pai</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pai</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">    ... getters</span><br><span class="line">    ... setters</span><br></pre></td></tr></table></figure><p>对于字牌，一共有东南西北中发白，七种类型，对应的number取值为1到7，在编码时还需要注意字牌是无法组成顺子的。</p><p>对于一场比赛，牌的数量类型都是早就决定好不会变的，唯一变的就是牌的顺序，我们只需定义好一个所有牌的集合，在有需要生成牌山的时候，直接将其打乱使用即可。</p><p>宝牌是否要在<code>class Pai</code>中定义？由于每场比赛，宝牌是变化的，与场况有关，所以不太适合放在其中。但是有一个例外——赤宝牌，我本想在Pai中增加一个属性aka/red，标示是否是赤宝牌，但想到现在只是在对手牌进行和牌、听牌的判断，增加这个字段与否和现在要解决的问题无关，索性就不管了，宝牌之类，留着后面再统一处理吧。</p><h2 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h2><p><img src="https://b1.loli.io/images/GjMLe.png" alt="image.png"></p><blockquote><p>相关代码会在整理后放到github上</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手牌和牌时的组成&quot;&gt;&lt;a href=&quot;#手牌和牌时的组成&quot; class=&quot;headerlink&quot; title=&quot;手牌和牌时的组成&quot;&gt;&lt;/a&gt;手牌和牌时的组成&lt;/h2&gt;&lt;p&gt;日本麻将除了特殊牌形（七对和国士）以外，都是 &lt;code&gt;a个顺子+b个刻子+1个雀头&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制的一个爬虫nekocat</title>
    <link href="http://blog.loli.io/2018/06/09/spider-01/"/>
    <id>http://blog.loli.io/2018/06/09/spider-01/</id>
    <published>2018-06-09T12:32:29.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 <a href="https://github.com/biezhi/elves" target="_blank" rel="noopener">https://github.com/biezhi/elves</a> 的思路，于是就开工了，大约一两周摸鱼的时间，就基本完成了，可以来github围观：<a href="https://github.com/chocotan/nekocat" target="_blank" rel="noopener">https://github.com/chocotan/nekocat</a><br>，名字是随便取的。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定时执行</li><li>自定义UA、代理池</li><li>支持多线程</li><li>可自定义Downloader实现headless chrome（大概）</li><li>失败重试</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>于是就找了一些网站开始爬了，注册了个域名，做了个界面，挂上了google adsense</p><p>网址：<a href="http://www.codetd.com" target="_blank" rel="noopener">www.codetd.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h2&gt;&lt;p&gt;最近想着爬一个IT技术站，找了JAVA的一些爬虫围观了下，嗯…都不太合心意，还是自制一个吧，参考了 &lt;a href=&quot;https://git
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RxJava使用线程池</title>
    <link href="http://blog.loli.io/2018/03/11/rxjava-parallel/"/>
    <id>http://blog.loli.io/2018/03/11/rxjava-parallel/</id>
    <published>2018-03-11T05:19:47.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为5的线程池</span></span><br><span class="line">ThreadPoolExecutor exec = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="number">5</span>, <span class="number">200</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .subscribeOn(Schedulers.from(exec))</span><br><span class="line">        .subscribe(i -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            System.out.println(i + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>由于我在subscribe中sleep了1s，所以我认为这五个数字会并发的执行到subscribe中去，期待会有如下的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-2</span><br><span class="line">3pool-1-thread-3</span><br><span class="line">4pool-1-thread-4</span><br><span class="line">5pool-1-thread-5</span><br></pre></td></tr></table></figure><p>然而事与愿违，实际的输出是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pool-1-thread-1</span><br><span class="line">2pool-1-thread-1</span><br><span class="line">3pool-1-thread-1</span><br><span class="line">4pool-1-thread-1</span><br><span class="line">5pool-1-thread-1</span><br></pre></td></tr></table></figure></p><p>嗯嗯？为什么没有并发执行subscribe里的代码呢？我以为是我自己的代码有问题，又陆续尝试了内置的一些Scheduler，consumer均是在同一个线程中执行的，好吧，看来是我理解错rxjava的Schedulers了，这货的from方法接收一个Executor参数，并不是指接下来的任务会提交给这个线程池并发的执行。</p><p>这大概也是RxJava和CompletableFuture的区别之一吧。搜索了一圈，用rxjava实现并发主要以以下几个方法</p><ol><li><p>在flatMap中使用obseveOn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.just(i).observeOn(Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;))</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>在flatMap中使用Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .flatMap(i -&gt; Flowable.fromFuture(CompletableFuture.completedFuture(i), Schedulers.from(exec))</span><br><span class="line">                .doOnNext(d -&gt; &#123;</span><br><span class="line">                    System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">        )</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li><li><p>使用ParallelFlowable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .runOn(Schedulers.from(exec))</span><br><span class="line">        .doOnNext(d -&gt; &#123;</span><br><span class="line">            System.out.println(d + <span class="string">"\t"</span> + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .sequential()</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure></li></ol><p>有两个要注意的地方</p><ol><li>RxJava在执行并发的时候，并不会使用Executor的maximumPollSize这个属性，corePollSize有多大，那么最大就有多少个线程</li><li>parallel()有一个重载方法可以传入并发数，默认为cpu核心数，在单核的服务器上这个数字是1，也就是不管Executor有多少个线程，只会用一个线程去执行任务</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>最近发现在使用UnicastProcessor和ParallelFlowable的时候有cpu占用高的情况，经过跟踪发现是这样的问题：</p><p>Flowable是支持背压的，所以在元素弹出过快的时候会抛出异常，而我又使用了retry，使得在抛出异常的时候会重新订阅Flowable，而UnicastProcessor只能被订阅一次，所以抛出了大量的IllegalStateException</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在瞎折腾rxjava，写了一段自认为能并发执行的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.loli.io/tags/java/"/>
    
      <category term="rxjava" scheme="http://blog.loli.io/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>换成Hexo了！</title>
    <link href="http://blog.loli.io/2016/01/28/%E6%8D%A2%E6%88%90Hexo%E4%BA%86%EF%BC%81/"/>
    <id>http://blog.loli.io/2016/01/28/换成Hexo了！/</id>
    <published>2016-01-28T13:36:27.000Z</published>
    <updated>2019-06-21T02:16:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>如题，看上去很不错，于是以后多发技术文</p><p>嗯嗯</p><p>test123</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，看上去很不错，于是以后多发技术文&lt;/p&gt;
&lt;p&gt;嗯嗯&lt;/p&gt;
&lt;p&gt;test123&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
